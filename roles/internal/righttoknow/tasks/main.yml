---
- name: Remove apache2
  apt:
    name: apache2
    state: absent

- name: Add key for passenger
  ansible.builtin.get_url:
    url: https://oss-binaries.phusionpassenger.com/auto-software-signing-gpg-key.txt
    dest: /usr/share/keyrings/phusionpassenger-archive-keyring.asc
- name: Add passenger apt repository
  apt_repository:
    repo: 'deb [signed-by=/usr/share/keyrings/phusionpassenger-archive-keyring.asc] https://oss-binaries.phusionpassenger.com/apt/passenger {{ansible_distribution_release}} main'
    state: present
    update_cache: yes

- name: Install nginx and passenger
  apt:
    pkg:
      - libnginx-mod-http-passenger
      - nginx
    state: present

# We want this directory to exist in development too so that
# things are as consistent as possible
# Basically everything in /data is stuff we want backed up that
# isn't the database
- name: Create data mountpoint
  file:
    state: directory
    path: /data

# On EC2 we're using a seperate EBS volume to hold application data
- name: Create filesystem on attached block storage
  filesystem:
    fstype: ext4
    dev: /dev/nvme1n1
  when: "'ec2' in group_names"

- name: Mount /data filesystem
  mount:
    path: /data
    # Mount device by UUID because that's needed to run on AWS Nitro based instances (e.g. t3)
    # See https://aws.amazon.com/premiumsupport/knowledge-center/boot-error-linux-nitro-instance/
    src: "UUID={{ ansible_facts['devices']['nvme1n1']['links']['uuids'][0] }}"
    fstype: ext4
    state: mounted
  when: "'ec2' in group_names"

- name: Create directories in /data
  file:
    path: "/data/{{ item[0] }}/{{ item[1] }}"
    owner: deploy
    group: deploy
    state: directory
  with_nested:
    - "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
    - ['cache', 'bundle', 'storage', 'xapiandbs']

- name: Ensure that deploy owns application directories
  file:
    state: directory
    owner: deploy
    group: deploy
    path: "/srv/www/{{ item[0] }}/{{ item[1] }}"
  with_nested:
    - "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
    - ['', 'shared']

- name: Link directories in /srv/www to /data
  file:
    state: link
    src: "/data/{{ item[0] }}/{{ item[1] }}"
    dest: "/srv/www/{{ item[0] }}/shared/{{ item[1] }}"
  with_nested:
    - "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
    - ['cache', 'bundle', 'storage', 'xapiandbs']

- name: Set the ruby version for the alaveteli deploy (production)
  copy:
    content: "{{ ruby_version_production }}"
    dest: /srv/www/production/shared/rbenv-version
  when: "'righttoknow_production' in group_names"

- name: Set the ruby version for the alaveteli deploy (staging)
  copy:
    content: "{{ ruby_version_staging }}"
    dest: /srv/www/staging/shared/rbenv-version
  when: "'righttoknow_staging' in group_names"

- name: Another Aleveteli config to force production environment
  template:
    src: rails_env.rb
    dest: /srv/www/{{ item }}/shared
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"

- name: Add newrelic configuration to disable agent
  template:
    src: newrelic.yml
    dest: /srv/www/{{ item }}/shared/
  vars:
    newrelic_app_name: "Right To Know{{ (item == 'production') | ternary('', ' Staging') }}"
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"

- name: Install wrapper script for setting correct version of ruby in path
  template:
    src: run.sh
    dest: /srv/www/{{ item }}/shared
    # Make it executable
    mode: 0755
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"

# Installing via bash so that rbenv is used. Otherwise would install gems for default system ruby
# We need to use 1.14.6 because the Gemfile.lock file is corrupted in Alaveteli 0.28.0.10 and if
# we use a later version of bundler it will complain and not deploy
- name: Install bundler gem (production)
  command: bash -lc "rbenv shell {{ ruby_version_production }}; gem install bundler --version 1.14.6"
  args:
    creates: "/home/deploy/.rbenv/versions/{{ ruby_version_production }}/lib/ruby/gems/*/gems/bundler-*"
  become: true
  become_user: deploy
  when: "'righttoknow_production' in group_names"

# Installing via bash so that rbenv is used. Otherwise would install gems for default system ruby
# We need to use 1.14.6 because the Gemfile.lock file is corrupted in Alaveteli 0.28.0.10 and if
# we use a later version of bundler it will complain and not deploy
- name: Install bundler gem (staging)
  command: bash -lc "rbenv shell {{ ruby_version_staging}}; gem install bundler --version 1.14.6"
  args:
    creates: "/home/deploy/.rbenv/versions/{{ ruby_version_staging }}/lib/ruby/gems/*/gems/bundler-*"
  become: true
  become_user: deploy
  when: "'righttoknow_staging' in group_names"

- name: Install packages required by Alaveteli
  apt:
    name:
      - build-essential
      # bundler is installed via gem, not as package
      - catdoc
      - elinks
      - gettext
      - ghostscript
      - gnuplot-nox
      - imagemagick
      - libicu-dev
      - libmagic-dev
      - libmagickwand-dev
      - libpq-dev
      - libsqlite3-dev
      - libxml2-dev
      - libxslt-dev
      - links
      - lockfile-progs
      - memcached
      - mutt
      - pdftk-java
      - poppler-utils
      - postgresql
      - postgresql-client
      - python3-yaml
      - rake
      - ruby
      - ruby-dev
      - redis-server
      - sqlite3
      - tnef
      - fonts-liberation  # Replaces ttf-bitstream-vera
      - unrtf
      - unzip
      - uuid-dev
      - wkhtmltopdf  # Available as standard package
      - wv
      - xapian-tools
    state: present

- name: Install sidekiq systemd unit (staging)
  template:
    src: sidekiq.service
    dest: /etc/systemd/system/sidekiq.service
    mode: "0644"
  vars:
    sidekiq_daemon_name: "sidekiq (staging)"
    sidekiq_user: deploy
    sidekiq_vhost_dir: /srv/www
    sidekiq_vcspath: staging/current
    sidekiq_rails_env: production
  when: "'righttoknow_staging' in group_names"
  notify: restart sidekiq

- name: Enable and start sidekiq (staging)
  systemd:
    name: sidekiq
    enabled: yes
    state: started
    daemon_reload: yes
  when: "'righttoknow_staging' in group_names"

- name: Install sidekiq systemd unit (Production)
  template:
    src: sidekiq.service
    dest: /etc/systemd/system/sidekiq.service
    mode: "0644"
  vars:
    sidekiq_daemon_name: "sidekiq (production)"
    sidekiq_user: deploy
    sidekiq_vhost_dir: /srv/www
    sidekiq_vcspath: production/current
    sidekiq_rails_env: production
  when: "'righttoknow_production' in group_names"
  notify: restart sidekiq

- name: Enable and start sidekiq (production)
  systemd:
    name: sidekiq
    enabled: yes
    state: started
    daemon_reload: yes
  when: "'righttoknow_production' in group_names"

- name: Link run-with-lockfile.sh so it's available system-wide
  file:
    src: "/srv/www/{{ 'staging' if ('righttoknow_staging' in group_names) else 'production' }}/current/commonlib/bin/run-with-lockfile.sh"
    dest: "/usr/bin/run-with-lockfile"
    force: true
    state: link

- name: Install dependency for postgresql_db
  apt:
    pkg: python3-psycopg2

- name: Create database
  postgresql_db:
    login_host: "{{ postgresql_host }}"
    login_user: root
    login_password: "{{ rds_admin_password }}"
    name: "rtk-{{ item }}"
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"

- name: Create posgresql role
  postgresql_user:
    login_host: "{{ postgresql_host }}"
    login_user: root
    login_password: "{{ rds_admin_password }}"
    db: "rtk-{{ item }}"
    name: "rtk-{{ item }}"
    password: "{{ (item == 'production') | ternary(db_password_production, db_password_staging) }}"
    priv: ALL
    no_password_changes: true
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"

- name: Create posgresql user rtk-production-readonly for metabase
  postgresql_user:
    login_host: "{{ postgresql_host }}"
    login_user: root
    login_password: "{{ rds_admin_password }}"
    db: "rtk-production"
    name: "rtk-production-readonly"
    password: "{{ rtk_production_readonly_postgresql_password }}"
    no_password_changes: true
  when: "'righttoknow_production' in group_names"

- name: Give the user rtk-production-readonly readonly access to the production righttoknow database
  postgresql_privs:
    login_host: "{{ postgresql_host }}"
    login_user: root
    login_password: "{{ rds_admin_password }}"
    db: "rtk-production"
    role: "rtk-production-readonly"
    privs: SELECT
    objs: ALL_IN_SCHEMA
  when: "'righttoknow_production' in group_names"

- name: Copy over database configuration for application
  template:
    src: database.yml
    dest: "/srv/www/{{ item }}/shared/database.yml"
    owner: deploy
    group: deploy
  vars:
    - stage: "{{ item }}"
    - password: "{{ (item == 'production') | ternary(db_password_production, db_password_staging) }}"
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
  notify: nginx restart

- name: Copy init scripts
  template:
    src: "init/{{ item[1] }}"
    dest: "/etc/init.d/{{ item[1] }}-{{ item[0] }}"
    mode: 0755
  vars:
    stage: "{{ item[0] }}"
  with_nested:
    - "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
    - ['send-notifications', 'foi-alert-tracks', 'alaveteli']

- name: Generate nginx config
  template:
    src: "nginx/{{ item }}"
    dest: /etc/nginx
  with_items:
    - nginx.conf
    - htpasswd
  notify: nginx reload

- name: Copy nginx config for the app redirects
  template:
    src: nginx/default
    dest: /etc/nginx/sites-available
    owner: root
    group: root
    mode: 644
  notify: nginx reload
  when: "'righttoknow_production' in group_names"

- name: Copy nginx config for the app
  template:
    src: nginx/stage
    dest: /etc/nginx/sites-available/{{ item }}
    owner: root
    group: root
    mode: 644
  vars:
    domain: "{{ righttoknow_domain }}"
    stage: "{{ item }}"
    password_protect: "{{ item == 'staging' }}"
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
  notify: nginx reload

- name: Enable sites
  file:
    src: /etc/nginx/sites-available/{{ item }}
    dest: /etc/nginx/sites-enabled/{{ item }}
    state: link
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['default','production'] if 'righttoknow_production' in group_names else [] ) }}"
  notify: nginx reload

- name: Apply Alaveteli config (production)
  template:
    src: general.yml
    dest: /srv/www/production/shared/
    owner: deploy
    group: deploy
  vars:
    domain: "{{ righttoknow_domain }}"
    site_name: "Right to Know"
    incoming_email_prefix: "foi+"
    staging_site: "0"
    override_all_public_body_request_emails: null
    stage: production
    stripe_publishable_key: "{{ stripe_publishable_key_live }}"
    stripe_secret_key: "{{ stripe_secret_key_live }}"
    stripe_webhook_secret: "{{ stripe_webhook_secret_production }}"
    enable_alaveteli_pro: true
    enable_pro_pricing: true
    pro_referral_coupon: "{{ pro_referral_coupon_production }}"
  notify: nginx restart
  when: "'righttoknow_production' in group_names"

- name: Apply Alaveteli Storage Config (production)
  template:
    src: storage.yml
    dest: /srv/www/production/shared/
    owner: deploy
    group: deploy
  notify: nginx restart
  when: "'righttoknow_production' in group_names"

- name: Apply Alaveteli config (staging)
  template:
    src: general.yml
    dest: /srv/www/staging/shared/
    owner: deploy
    group: deploy
  vars:
    domain: "{{ righttoknow_domain }}"
    site_name: "Right to Know (STAGING)"
    incoming_email_prefix: "foitest+"
    staging_site: "1"
    override_all_public_body_request_emails: "contact@righttoknow.org.au"
    stage: staging
    stripe_publishable_key: "{{ stripe_publishable_key_test }}"
    stripe_secret_key: "{{ stripe_secret_key_test }}"
    stripe_webhook_secret: "{{ stripe_webhook_secret_staging }}"
    enable_alaveteli_pro: true
    enable_pro_pricing: true
    pro_referral_coupon: "{{ pro_referral_coupon_staging }}"
  notify: nginx restart
  when: "'righttoknow_staging' in group_names"

- name: Apply Alaveteli Storage Config
  template:
    src: storage.yml
    dest: /srv/www/{{ item }}/shared/storage.yml
    owner: deploy
    group: deploy
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
  notify: nginx restart

- name: Apply user spam scorer config
  template:
    src: user_spam_scorer.yml
    dest: "/srv/www/{{ item }}/shared/user_spam_scorer.yml"
    owner: deploy
    group: deploy
  with_items: "{{ ['staging'] if 'righttoknow_staging' in group_names else ( ['production'] if 'righttoknow_production' in group_names else [] ) }}"
  notify: nginx restart


- name: Add deploy user to adm group so it can read mail logs
  user:
    name: deploy
    groups: adm
    append: yes

- name: Install varnish
  apt:
    pkg: varnish

- name: Update varnish config
  copy:
    src: default.vcl
    dest: /etc/varnish
  notify: restart varnish

- name: Update varnish startup config
  copy:
    src: varnish.service
    dest: /lib/systemd/system/varnish.service
  notify: restart varnish

- import_tasks: certificates.yml
- import_tasks: cron.yml

- name: Install postfix (and opendkim) for email handling
  apt:
    pkg:
      - postfix
      - opendkim
      # Only needed to run opendkim-genkey
      # TODO: Probably don't need opendkim-tools in production
      - opendkim-tools

- name: Create directory for DKIM keypair
  file:
    path: /etc/dkimkeys/{{ righttoknow_domain }}
    owner: opendkim
    group: opendkim
    mode: 0700
    state: directory

# Generated public/private keypair for opendkim with:
# opendkim-genkey -b 2048 -d righttoknow.org.au -D /etc/dkimkeys -s default -v

- name: Apply DKIM keypair
  copy:
    src: "dkimkeys/{{ item }}"
    dest: /etc/dkimkeys/{{ righttoknow_domain }}
    owner: opendkim
    group: opendkim
    mode: "0600"
  with_items:
    - default.private
    # It isn't strictly necessary to copy across default.txt as this is just a record of what needs to be added to DNS
    # Doing this to try to be a little self-documenting, I guess.
    - default.txt
  notify: restart opendkim

- name: Create directory for opendkim socket that's accessible by postfix
  file:
    path: /var/spool/postfix/opendkim
    owner: opendkim
    group: postfix
    state: directory

- name: Postfix needs to be part of opendkim group to access the socket
  user:
    name: postfix
    groups: opendkim

- name: Update opendkim configuration
  template:
    src: "opendkim.conf"
    dest: /etc
  notify: restart opendkim

- name: Update postfix configuration
  template:
    src: "postfix/{{ item }}"
    dest: /etc/postfix
  with_items:
    - master.cf
    - main.cf
    - transport
    - regexp
  notify: restart postfix

- name: Set mailname for outbound mail
  template:
    src: mailname
    dest: /etc/mailname
  notify: restart postfix

- name: Configure postfix logs to go to their own directory
  copy:
    src: 50-default.conf
    dest: /etc/rsyslog.d
  notify: restart rsyslog

- name: Install memcached
  apt:
    pkg: memcached
